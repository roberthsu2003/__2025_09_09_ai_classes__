<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>俄羅斯方塊</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f0f0f0;
            font-family: Arial, sans-serif;
        }
        #gameContainer {
            display: flex;
            align-items: flex-start;
        }
        #gameCanvas {
            border: 2px solid #333;
            background-color: #000;
        }
        #gameInfo {
            margin-left: 20px;
            font-size: 18px;
        }
        #startButton {
            padding: 10px 20px;
            font-size: 18px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 10px;
        }
        #startButton:hover {
            background-color: #45a049;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="400" height="800"></canvas>
        <div id="gameInfo">
            <h2>俄羅斯方塊</h2>
            <p>分數：<span id="score">0</span></p>
            <p>等級：<span id="level">1</span></p>
            <button id="startButton">開始遊戲</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startButton = document.getElementById('startButton');
        const scoreElement = document.getElementById('score');
        const levelElement = document.getElementById('level');

        const COLS = 10;
        const ROWS = 20;
        const BLOCK_SIZE = 40;

        const COLORS = [
            null,
            '#FF0D72',
            '#0DC2FF',
            '#0DFF72',
            '#F538FF',
            '#FF8E0D',
            '#FFE138',
            '#3877FF'
        ];

        const SHAPES = [
            [],
            [[1, 1, 1, 1]], // I
            [[2, 2, 0], [0, 2, 2]], // S
            [[0, 3, 3], [3, 3, 0]], // Z
            [[4, 4, 4], [0, 4, 0]], // T
            [[5, 5], [5, 5]], // O
            [[6, 0, 0], [6, 6, 6]], // J
            [[0, 0, 7], [7, 7, 7]]  // L
        ];

        let board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
        let piece;
        let score = 0;
        let level = 1;
        let dropStart = Date.now();
        let gameOver = false;

        function newPiece() {
            const typeId = Math.floor(Math.random() * (SHAPES.length - 1)) + 1;
            const shape = SHAPES[typeId];
            piece = {
                x: Math.floor(COLS / 2) - Math.floor(shape[0].length / 2),
                y: 0,
                shape: shape,
                color: COLORS[typeId]
            };
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBoard();
            drawPiece();
        }

        function drawBoard() {
            board.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value > 0) {
                        ctx.fillStyle = COLORS[value];
                        ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                        ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                    }
                });
            });
        }

        function drawPiece() {
            ctx.fillStyle = piece.color;
            piece.shape.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value > 0) {
                        ctx.fillRect((piece.x + x) * BLOCK_SIZE, (piece.y + y) * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                        ctx.strokeRect((piece.x + x) * BLOCK_SIZE, (piece.y + y) * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                    }
                });
            });
        }

        function move(p) {
            if (!isValid(p)) {
                return false;
            }
            piece = p;
            return true;
        }

        function rotate(p) {
            let clone = JSON.parse(JSON.stringify(p));
            const shape = clone.shape;
            // Transpose matrix
            const newShape = shape[0].map((_, colIndex) => shape.map(row => row[colIndex]));
            // Reverse each row to get a 90-degree clockwise rotation
            newShape.forEach(row => row.reverse());
            clone.shape = newShape;
            return clone;
        }

        function isValid(p) {
            return p.shape.every((row, dy) => {
                return row.every((value, dx) => {
                    let x = p.x + dx;
                    let y = p.y + dy;
                    return (
                        value === 0 ||
                        (x >= 0 && x < COLS && y < ROWS && board[y] && board[y][x] === 0)
                    );
                });
            });
        }

        function drop() {
            let p = { ...piece, y: piece.y + 1 };
            if (isValid(p)) {
                piece.y++;
            } else {
                freeze();
                clearLines();
                if (gameOver) return;
                newPiece();
            }
        }

        function freeze() {
            piece.shape.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value > 0) {
                        board[piece.y + y][piece.x + x] = value;
                    }
                });
            });
            if (piece.y === 0) {
                gameOver = true;
            }
        }

        function clearLines() {
            let lines = 0;
            board.forEach((row, y) => {
                if (row.every(value => value > 0)) {
                    lines++;
                    board.splice(y, 1);
                    board.unshift(Array(COLS).fill(0));
                }
            });
            if (lines > 0) {
                score += lines * 10 * level;
                scoreElement.textContent = score;
                if (score > level * 100) {
                    level++;
                    levelElement.textContent = level;
                }
            }
        }

        function gameLoop() {
            let now = Date.now();
            let delta = now - dropStart;
            if (delta > 1000 / level) {
                drop();
                dropStart = Date.now();
            }

            if (!gameOver) {
                draw();
                requestAnimationFrame(gameLoop);
            } else {
                alert('遊戲結束！');
            }
        }

        document.addEventListener('keydown', event => {
            if (event.keyCode === 37) { // Left
                move({ ...piece, x: piece.x - 1 });
            } else if (event.keyCode === 39) { // Right
                move({ ...piece, x: piece.x + 1 });
            } else if (event.keyCode === 40) { // Down
                drop();
            } else if (event.keyCode === 38) { // Up (Rotate)
                const p = rotate(piece);
                if (isValid(p)) {
                    piece = p;
                }
            }
        });

        startButton.addEventListener('click', () => {
            board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
            score = 0;
            level = 1;
            scoreElement.textContent = score;
            levelElement.textContent = level;
            gameOver = false;
            newPiece();
            gameLoop();
        });
    </script>
</body>
</html>
